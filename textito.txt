Holaa! <3

Respuesta: Holii que hay!

Consultas SQL

CREATE DATABASE bootcampfsj30;
------------------------------------------------------------------------

CREATE TABLE estudiantes(
    nombre varchar(255),
    edad int(3),
    promedio decimal(2,3)
);
------------------------------------------------------------------------

USE bootcampfsj30;

-- Indica que DECIMAL 3->enteros y 2->decimales después del punto
-- Con esto se modifica una columna, en este caso se modificó promedio, antes no tenía tipo, ahora se le estableció (3,2)
ALTER TABLE estudiantes MODIFY COLUMN promedio DECIMAL (3,2);
-------------------------------------------------------------------------

-- Con esta secuencia se agrega una llave primaria llamada id tipo int
-- Con AUTO_INCREMENT es para que no se resetee, va a incrementar y no se quedará vacío
ALTER TABLE estudiantes ADD id INT PRIMARY KEY NOT NULL AUTO_INCREMENT;
------------------------------------------------------------------------

-- secuencia para eliminar una tabla de la BD bootcampfsj30
DROP TABLE estudiantes;
------------------------------------------------------------------------

-- Se agrega nuevos datos a la fila, el id se agregó solito debido al AUTO_INCREMENT
INSERT INTO estudiantes (nombre, edad, promedio) VALUES ('Andrea', 23, 8.1);
------------------------------------------------------------------------

-- Con truncate se vacía la tabla
TRUNCATE TABLE estudiantes;
-------------------------------------------------------------------------

-- Sentencia para mostrar todos los datos de la tabla
-- select es para SELECCIONAR, * es para elegir todos los datos, from es DE, la tabla "estudiantes", where es CUANDO cierto dato cumpla con, un promedio > 9
SELECT * FROM estudiantes WHERE promedio > 9;
-------------------------------------------------------------------------

-- update actualiza, la tabla estudiantes set sustituye o sobrepone, el promedio actual a 7.5, where donde, el id sea 1, osea me cambiaría el promedio a mí
UPDATE estudiantes SET promedio = 7.5 WHERE id = 1;
------------------------------------------------------------------------

-- Después de escribir esta secuencia, las demás que le siguen es para hacer pruebas. sirve para probar consultas de DML, osea que no sirve para CREATE, DROP Y ALTER
START TRANSACTION;
-------------------------------------------------------------------------

-- delete elimina la fila del id 1, o sea mi nombre
DELETE FROM estudiantes WHERE id = 1;
------------------------------------------------------------------------

-- se usa para deshacer los cambios realizados durante una transacción que aún no ha sido confirmada
ROLLBACK;
------------------------------------------------------------------------

-- Se crea otra llave foránea a la tabla estudiantes aparte de la propia que ya tenía
ALTER TABLE estudiantes ADD id_curso INT;
------------------------------------------------------------------------

-- agrega un contrato o restricción con el nombre de fk_curso_estudiante para enlazar la llave foránea llamada recién agregada en la tabla estudiantes(id_curso) y que va a estar referenciada a la llave foránea de la tabla cursos(id_curso)
ALTER TABLE estudiantes ADD CONSTRAINT fk_curso_estudiante FOREIGN KEY (id) REFERENCES cursos(id_curso);
------------------------------------------------------------------------

-- Agregar 3 cursos a la BD cursos, se llamaron desde nombre_curso
INSERT INTO cursos (nombre_curso) VALUES
('Programación'),
('Base de datos'),
('Análisis de datos');
-------------------------------------------------------------------------

-- Agregar 6 estudiantes a la BD estudiantes, se llamaron desde nombre,edad,promedio,id_curso
INSERT INTO estudiantes(nombre,edad,promedio,id_curso) VALUES
('Mauricio', 21, 9.50,3),
('Hector', 24, 8.10,1),
('Valentina', 22, 7.85,2),
('Esteban', 23, 9.20,3),
('Luisa', 25, 8.60,2),
('Jairo', 24, 9.70,1)
-------------------------------------------------------------------------

-- selecciona los valores 
SELECT estudiantes.id, estudiantes.nombre, estudiantes.edad, estudiantes.promedio, estudiantes.id_curso, cursos.nombre_curso
-- de la tabla estudiantes y lo UNE con la tabla cursos DONDE (On sustituye el where cuando se unen ms tablas) el id de estudiantes sea igual al id del curso
FROM estudiantes INNER JOIN cursos ON estudiantes.id = cursos.id_curso;
-- donde el nombre del curso sea Base de datos, entonces que encuentre los estudiantes con promedio > 9 de esa materia
WHERE cursos.nombre_curso = 'Base de datos' AND estudiantes.promedio > 9;
-------------------------------------------------------------------------

-- Mostrar o contar el número total de estudiantes de X curso -> FUNCION COUNT
-- COUNT() cuenta el número de filas (alumnos) y GROUP BY agrupa esas filas por el nombre o ID del curso.
SELECT cursos.nombre_curso, COUNT (estudiantes.id) AS cantidad_estudiantes FROM cursos
INNER JOIN estudiantes ON cursos.id_curso = estudiantes.id_curso
GROUP BY cursos.nombre_curso ORDER BY cantidad_estudiantes DESC;
-------------------------------------------------------------------------

-- agregar un nuevo estudiante con un curso asignado primeramente
INSERT INTO estudiantes(nombre, edad, promedio, id_curso) VALUES
('Juan',27,7.30,1);
---------------------------------------------------------------------------

-- Mostrar el promedio de edad por curso. AVG agarra todos esos datos y saca promedio, AVG es una media
SELECT cursos.nombre_curso, AVG(estudiantes.edad) AS promedio_edad_estudiantes FROM cursos
INNER JOIN estudiantes ON cursos.id_curso = estudiantes.id_curso
GROUP BY cursos.nombre_curso
--------------------------------------------------------------------------

-- Mostrar los cursos que tengan un promedio de notas mayor a 8
SELECT cursos.nombre_curso, AVG(estudiantes.promedio) FROM cursos
INNER JOIN estudiantes ON cursos.id_curso = estudiantes.id_curso
GROUP BY cursos.nombre_curso
-- Gracias a having, se usa como filtro en vez del where, porque estamos usando funciones (count, avg, etc). En este caso estamos filtrando promedios > 8
-- se usa después de agrupar (GROUP BY)
-- el where para filas indivuales o antes de la agregacion, antes de usar having
HAVING 
	AVG(estudiantes.promedio) > 8;
----------------------------------------------------------------------------

-- El LEFT JOIN incluye todos los registros de la tabla de la izquierda (alumnos), incluso si no hay coincidencias en la tabla de la derecha (cursos).
SELECT cursos.nombre_curso, COUNT (estudiantes.id) AS cantidad_estudiantes FROM cursos
LEFT JOIN estudiantes ON cursos.id_curso = estudiantes.id_curso
-- ordena los estudiantes de forma Descendente
GROUP BY cursos.nombre_curso ORDER BY cantidad_estudiantes DESC;

La BD Relacional o SQL es más estructurada, utiliza el lenguaje de consulta y se maneja a través de almacenar los datos en tablas, es decir que en columnas y filas
La BD No Relacional o No SQL es menos estructurada, porque no tiene un esquema o tabla a seguir, sino que lo que se termina guardando depende de como tomar los modelos para que lo cumplan. Puede almacenar datos tipos json, osea objetos, guarda en conexiones en ves de tablas

Librería es una porción
Biblioteca es el conjunto de librerías (Router y DOM son librerías de React)
Framework 
Angular para el frontend y Laravel para el Backend son Frameworks

--------------------------------LARAVEL----------------------------------------------
composer global require laravel/installer -> instala el instalador de laravel
gracias a ello podemos crear proyectos laravel más facil

--CREAR NUEVO PROYECTO Laravel 
laravel new
(colocas nombre del proyecto)
none
1
no
mysql
no (database migrations)
yes (npm install)

-----------MIGRACIONES = TABLAS (Así se dice en esta área, nos referimos a las tablas)------------------

--Crear nuevo MODELO (Product) con su respectivo CONTROLLER AUTOMÁTICO (ProductController) gracias al -c
php artisan make:model Product -c

--Otra forma de crear un Modelo con Migración, Controlador y Recurso de una sola vez
php artisan make:model Product -mcr

--En caso que lo decidas crear individualmente y con su respectivo código base
php artisan make:controller ProductController -r

--Crear nueva tabla a migrar (El NOMBRE de las tablas deben ser en plural)
php artisan make:migration create_products_table
php artisan make:migration create_categories_table

--Después de crear tablas, para migrarlas al phpmyadmin
php artisan migrate

--Actualizar la migración en phpmyadmin cuando se han hecho cambios en VScode
php artisan migrate:refresh
--Pero lo recomendable es hacer rollback y luego volver a migrar, refresh da errores
--Refresh da de baja las migraciones y las vuelve a levantar, pero lo hace con todas las migraciones, no solo una, por eso no es recomendable
--Reset elimina todas las migraciones

--Eliminar el último lote de migraciones ya hecho, es decir que deshce el último cambio de migración
php artisan migrate:rollback

--A partir de la version 11 de LARAVEL, hay que instalar la api, ya no la trae
php artisan install:api
--Gracias a instalarla nos genera migraciones por default y genera el archivo api.php e installa sanctum

--En caso que ya haya BD y solo se tenga que migrar de phpmyadmin hacia VScode
php artisan make:model Product -cr
--Ya no se usa -m porque ya están las migraciones (tablas de BD)

--ORM sirve para facilitarnos cómo trabajar con una base de datos relacional, Eloquent es un ORM y es el que usa LARAVEL
--ORM Eloquent en nuestro traductor, es quien habla con el gestor de Base de datos en sentencias SQL
--Nosotros usamos POO, ORM lo traduce a Q-SQL para hablar con la BD y nos devuelve en POO

--LEVANTAR PROYECTO
php artisan serve

--Agregar SOFTDELETES en una migración aparte, en este caso a otra tabla posts
--Esto se hace en caso que ya se hayan creado las tablas y decido agregar más datos a la tabla
php artisan make:migration add_softdeletes_to_posts --table=posts

--------------------------------BLADE TEMPLATE----------------------------------------------

--En public van los archivos puros, como el css puro, el js puro
--En Resources van los archivos compilados, el css compilado, el js compilado
--Con blade, el usuario puede ver a través de "inspeccionar" lo que se ha hechom ya que pasa al frontend
